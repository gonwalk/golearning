# 概述

Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。

另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。

正常的使用缓存流程大致是，数据查询先从缓存中去读取查询，如果key不存在或者key已经过期，再从数据库中进行查询，并把查询到的对象放进缓存。如果数据库查询对象为空，则不放进缓存。


# 缓存击穿
  
**缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。**

其实，大多数情况下这种情况也很难对数据库服务器造成压垮性的压力，能达到这么高并发量的公司，肯定会对这些热点数据做处理。面对这种情况，比较务实主义的做法，就是对热点数据早早地做好准备，直接将其设为永不过期就好。


# 缓存穿透（都从数据库中查）
缓存穿透，是在查询数据库中~~**一定不存在的数据**~~时发生的。

## 产生原因

程序在处理缓存时，一般是先从缓存查询，如果缓存没有这个key则获取的值为null，这样就会从DB中查询，并设置到缓存中去。
按这种做法，当查询一个一定不存在的数据值，由于缓存是一定不能命中的，需要从数据库查询，而从DB中查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

## 解决方式
1. 最好对于每一个缓存key都有一定的规范约束，这样在程序中对不符合parttern的key 的请求可以拒绝。（但一般key都是通过程序自动生成的）

2. 将可能出现的缓存key的组合方式的所有数值以hash形式存储在一个很大的bitmap中<布隆过滤器>（需要考虑如何将这个可能出现的数据的hash值之后同步到bitmap中， eg. 后端每次新增一个可能的组合就同步一次，或者 穷举），一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

3. *常用的处理方式*： 如果对应在数据库中的数据都不存在，我们将此key对应的value设置为一个默认的值，比如“NULL”，并设置一个缓存的失效时间。当然这个key的时效比正常的时效要小的多


## 代码示例
使用缓存的原始方式如下
```markdown
//从缓存中获取数据[较快的方式]
data = getfromcache(id)
if data != null{ // 缓存有，直接返回缓存数据
    return data 
}
//缓存中没有，从数据库中获取数据[较慢的方式]
data = getfromdb(id)
//缓存1天
if data != nil{ // 如果数据库查询对象为空，则不放进缓存
    setintocache(id, data, 86400)  //单位秒 24 * 60 * 60 = 86400
}

return data
```

代码流程说明

参数传入对象主键ID
根据key从缓存中获取对象
如果对象不为空，直接返回
如果对象为空，进行数据库查询
如果从数据库查询出的对象不为空，则放入缓存（并设定过期时间）

想象一下这个情况，如果传入的参数id为-1，会怎么样？这个id=-1，就是数据库中一定不存在的对象。出现这种情况，程序就会每次都去查询数据库，而每次从数据库中查询得到的值都是空，导致每次都不会进行缓存设置。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。

# 缓存雪崩

缓存雪崩，是指在某一个时间段，缓存集中过期失效。

## 场景分析
产生雪崩的原因之一，比如每年双十一、双十二零点抢购活动开始之际，商品在这时比较集中地放入了缓存，如果缓存一个小时，那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。这样对这批商品的访问查询，就都落到了数据库上。对于数据库而言，就会产生周期性的压力波峰。
面对这种情况，一般是会对不同对分类商品，设置不同对缓存周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间。另外，对热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。自然形成的缓存雪崩出现的情形，一定是在某个时间段集中创建缓存。如果集中创建缓存的时候（会集中从数据库中取数据）数据库能顶住压力，那么缓存集中过期的时候，数据库也应该能够顶住压力，无非就是对数据库产生周期性的压力而已。
而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

## 产生原因
指的是大量缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。

## 解决方式
这个没有完美的解决办法，但可以分析用户行为，可以通过设置不同的过期时间，尽量让失效时间点均匀分布。
用加分布式锁或者分布式队列的方式保证缓存的单线程（进程）写 （eg. redis的 SETNX），从而避免失效时大量的并发请求落到底层存储系统上。在加锁方法内先从缓存中再获取一次(防止另外的线程优先获取锁已经写入了缓存)，没有再查DB写入缓存。 （当然也可以： 在没有获取锁(tryLock)的线程中一直轮询缓存，至超限时）

# 参考
[实例解读什么是Redis缓存穿透、缓存雪崩和缓存击穿] (https://baijiahao.baidu.com/s?id=1619572269435584821&wfr=spider&for=pc "redis缓存击穿、穿透、雪崩的区别")

谈谈服务端缓存的几种用法 https://segmentfault.com/a/1190000002698071